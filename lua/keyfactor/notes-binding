bind
outer
toggle

wring
redo
...set...?
...get...?
on











separately for actions and params (or some subset of params?)
    - assign raw, don't attempt to evaluate
    - evaluate but return/preserve original
    - evaluate and only keep result?


on: evaluate and return result; preserve original

redo: usually evaluate but preserve original; sometimes maybe assign raw
    - usually want to keep outer params intact

wring: usually want to evaluate inner params and only keep result

wring possibilities:
    - set wring action + selection ids
        - do/dont do the action
    wring.set(paste)

    - do whatever the wring action is, set selection ids (e.g. for redo)
    wring.action:with{wring.register}

    - if wring action is not already (variant of?) x, set it. if selection ids correspond to that
    action, then increment; otherwise do the action and set selection ids
    on(wring{namespace="thing"}.is_active)._then(wring{increment="depth"})._else(wring{paste, namespace="paste"})

    - if selection ids set, do whatever the wring action is. otherwise, set the wring action to a
    fallback, do either it or a separate initialization action, set selection ids, and possibly
    force an increment
    on(wring.is_active)._then(wring{increment="depth"}._else(
        wring.set{on(wring.is_active)._then(nil)._else(yank), replace}
        )


action:
    params get passed

    

go:
    - resolve "with" blocks to obtain params;
        - as long as there is at least one "with" block, even if empty, these params replace the
          ones from the context.params passed to this go
        - if there were no go blocks, default to context.params
    - execute wrapped bindables or callables
        - bindables get passed full context (with params replaced)
        - callables get just params
        - wrapped tables:
            - first, list-like portion is treated recursively
            - if any context.key is appears as key of table, also treat its value recursively
    - returns self

    - params:
        params (passed in)
        escape = integer - needed for?
        static = boolean - need for?
        remaining params assumed part of params

on:

toggle:
    -resolving this has the side effect of setting internal state so that resolving it again allows
    for incrementing
    -optional params for setting a flag for resetting?


redo:
    list-like part: actions are stored and executed (unless escape=true)
    escape boolean
    params boolean
    namespace string


    




Worked examples:

set.redo{action=on.shift(thing1)._else(thing2)}
    -- sets redo action to either thing1 or thing2, depending on current value of shift, after
    performing the action

set.redo{action=on.shift{bind(thing1)}._else(bind(thing2))}
    -- sets redo action to either thing1 or thing2, depending on current value of shift, but does
    not perform either action

set.redo{action=go(on.shift(thing1)._else(thing2))}
    -- sets redo action to the conditional on.shift(thing1)._else(thing2), which selects thing1 or
    thing2 depending on future value of shift, after performing either thing1 or thing2 depending
    on current value of shift

set.redo{action=bind(on.shift{thing1}._else{thing2})}
    -- sets redo to a conditional action, which selects thing1 or thing2 depending on future value
    of shift, but does not perform either action (or evaluate conditional at the moment)

set.redo{on.shift{action=bind(thing1)}._else{action=bind(thing2)}}
on.shift{set.redo{action=bind(thing1)}}._else{set.redo{action=bind(thing2)}}
    -- both are more verbose versions of second example,
    set.redo{action=on.shift{bind(thing1)}._else(bind(thing2))}


go(set.redo{action=go.select_textobject{lotsa stuff}})




go(action)
    -- no with block, so resolved as go(action):with{outer_params}
    -- outer_params are then forgotten, returns self/go(action) as usual

go(action):with{}
    -- resolve action with params set to {}

go(action):with{params}
    -- outer_params used to resolve params, which are used to resolve action
    -- returns self (before resolution, i.e., go(action):with{params}), forgetting outer_params


go(action):with{outer()}
    -- equivalent to go(action), except can be combined with outer with clauses to only override
    some of outer



go(lock.wring{
    action=bind{
        go.paste,
        lock.redo{action=bind(go.paste:with{point_operator, register})},
    }
}):with(register)



----

on binding behavior
    - on.condition: returns true if condition, else nil
    - on.condition(value):
        if condition, then
            if value is bindable, resolves it and returns whatever it returns
            else returns value
        else returns nil
    - on.condition._else(value): returns true if condition, else:
        if value is bindable, resolves it and returns whatever it returns
        else returns value
    - on.condition(value1)._else(value2): etc.

go(action):with((table of) bindables) or go.action(bindables)
    - each entry:
        - if key is string, it refers to key of params
            - double underscores address into nested tables of params
            - if value is table, it is recursively resolved, resulting in table that gets assigned
              to params[key] (replaces, does not extend, params[key])
            - if value is bindable, it is resolved and returned value is assigned to params[key]
            - otherwise, value is assigned directly to params[key]
        - otherwise, key should be numeric, in list-like range of table indices (these are evaluated first, in
          order)
            - value can be bindable, in which case it should return a table containing key=value
              pairs (which will not be resolved further, and errors will be logged for non-string
              keys in the table)
            - or value can be table, in which case it is recursively resolved to produce key=value
              pairs, with entries treated as though they were entries of original table of
              bindables





Can we now avoid separate "bind" phase?
    - Still need to evaluate conditionals like "on.insert.go.something(else nil)" to see
      whether we get any action, or nil in which case we pass to next layer
        - But we could have separate layer fallthrough mechanism. Maybe action returns something?

E.g.:
for each action-binding in the layer:
    eval action-binding with current context
    if returns false, break; don't go to next layer
    if returns true, continue within this layer; don't go to next layer
    if returns nil, continue within this layer

Or:
for each action-binding in the layer:
    eval action-binding with current context
    if returns truthy, flag don't go to next layer
    in every case continue within current layer

To stop execution within layer could have construct like:
    on( go.do_something_that_might_fail ).go.do_something_else
or maybe:
    go.do_something_else:with{ go.do_something_that_sets_cancel_flag_if_fails }?


-------

Eval action-binding with current context:

- just look at __exec, same as action. Call it, passing context.

- on, when called with __exec, raises error if it is not an action binding??
    - returns false if condition unmet and no _else

- action class/wrapper does following on __exec:
    - resolves any bindings from :with method. These have __bind metamethod taking context and
      returning params, which gets rolled into context
    - fills relevant parts of params with defaults?
    - calls :exec (or other underlying callable?) with params
    - returns true
